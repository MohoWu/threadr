% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/sp_distance.R
\name{sp_distance}
\alias{sp_distance}
\title{Function to find distances between two spatial objects in metres or
kilometres.}
\usage{
sp_distance(sp1, sp2, proj = NA, cores = 1, unit = "m")
}
\arguments{
\item{sp1}{Spatial object one.}

\item{sp2}{Spatial object two.}

\item{proj}{A proj4 string for the distance calculations. Defaults to the
Mollweide projection, but should be changed to a location-specific projection
if possible.}

\item{cores}{Number of cores for the function to use. Not available for
Windows systems.}

\item{unit}{If \code{"km"}, the returned vector is returned in kilometres
rather than metres.}
}
\description{
\code{sp_distance} calculates the distance between a spatial object and
another spatial object. An example of usage is when an object containing
locations of cities is tested against coastline information to determine how
far cities are away from the coast.
}
\details{
\code{sp_distance} uses \code{rgeos::gDistance} for the distance calculations.
This function returns distances based on the unit of the projection system
contained within the spatial objects. By default, the Mollweide projection
is used. The Mollweide projection is applicable in any location on Earth, but
the accuracy of the returned values is dependent on location.

If the spatial objects are located in a zone which has a more appropriate
projection system, it is highly recommended that this is used. For example,
spatial data in New Zealand should be projected in the New Zealand Transverse
Mercator 2000 while data in the UK should be projected in British National
Grid; both of which have metre units (\code{+units=m}).

\code{sp_distance} supports parallel processing by forking the
\code{rgeos::gDistance} function across multiple cores. This can make the
distance calculations much faster.
}
\examples{
\dontrun{
# Simple usage
# Calculate the distances of places from the coastline
distances <- sp_distance(sp.places, sp.coast.line, unit = "km")

# Speed the function up by using multiple system cores
distances <- sp_distance(sp.places, sp.coast.line, unit = "km", cores = 4)


# Usage for transforming a data frame
# Load shapefiles
# Coastline, spatial lines
sp.coast.line <- readOGR("coastlines, "coastlines")

# Places in the UK, spatial points
sp.places <- readOGR("great-britain", "places")

# Get a data frame from the sp.places object
data.places <- data.frame(sp.places)

# Find distances between every place in sp.places and sp.coast.line
# We are in the UK, therefore use British National Grid for the projection
proj <- "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs"

# Apply parallel function and add variable to data frame
data.places$distance <- sp_distance(
  sp.places, sp.coast.line, unit = "km", cores = 8, proj = proj)

# Have a look
head(data.places)

London 33.4
Basingstoke 43.5
York 37
Tobermory 0.22
Charlbury 60.3

# London will be dependent on where the coastline is set after the River
# Thames's mouth.
}
}
\author{
Stuart K. Grange
}
\seealso{
\code{\link{gDistance}}, \code{\link{spTransform}},
\code{\link{mclapply}}
}

