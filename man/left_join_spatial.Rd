% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/left_join_spatial.R
\name{left_join_spatial}
\alias{left_join_spatial}
\title{Function for a point-in-polygon test.}
\usage{
left_join_spatial(df, latitude = "latitude", longitude = "longitude",
  polygons = NULL)
}
\arguments{
\item{df}{A data frame containing latitude and longitude variables.}

\item{latitude}{\code{df}'s latitude variable name.}

\item{longitude}{\code{df}'s longitude variable name.}

\item{polygons}{A spatial polygon object to be joined to \code{df}.}
}
\description{
left_join_spatial tests if a point is within a spatial polygon and joins
tabular data from a spatial object if the match TRUE. This process is
analogous to a SQL left join with the match being a spatial intersection.
}
\details{
Points to be tested are stored in a data frame with latitude and longitude
(WGS84) while the polygons must be stored in a spatial object. The result is
the input data frame with the joined data within the spatial polygon.

Ensure that the data frame containing points and the polygons are both
projected as WGS84 ("+proj=latlong +datum=WGS84"; see sp::spTransform).

sp::over is used for the point-in-polygon test

Function can be rather slow when many points and many polygons are to be
joined.
}
\examples{
\dontrun{

# Join air quality zone (for PM10) information for 280 000 latitude and
longitude pairs within Europe
data.join <- left_join_spatial(data.tidy, latitude = "latitude",
  longitude = "longitude", polygons = shape.file.pm10)
}
}
\author{
Stuart K. Grange
}

